services: # Раздел, описывающий контейнеры, которые требуются для работы Order-сервиса
  order-service:
    build: 
      context: ../../..
      dockerfile: deploy/docker/order/Dockerfile

    container_name: order-service
    # Явное имя контейнера — удобно для логов и отладки
    ports:
      - "${EXTERNAL_HTTP_PORT}:${HTTP_PORT}"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      # Проверяем готовность API через health endpoint
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 15s
      # Даём приложению время на запуск

    restart: unless-stopped

    networks:
      - microservices-net

    depends_on:
      postgres-order:
        condition: service_healthy

  postgres-order: # Контейнер с PostgreSQL, используемый для хранения данных заказов
    image: "${POSTGRES_IMAGE_NAME}"
    # Используем официальный образ PostgreSQL версии 17 на базе Alpine Linux
    # Это лёгкая и быстрая сборка, которая экономит ресурсы

    container_name: postgres-order
    # Устанавливаем уникальное имя контейнера, чтобы было удобно обращаться к нему в CLI и при отладке

    env_file:
      - .env

    volumes:
      - postgres_order_data:/var/lib/postgresql/data
      # Определяем том, который будет использоваться для хранения данных PostgreSQL
      # Он сохраняет данные между перезапусками контейнера

    # ports:
      # - "${EXTERNAL_POSTGRES_PORT}:5432"
      # Пробрасываем внутренний порт PostgreSQL (5432) на порт хоста
      # Это нужно, чтобы другие сервисы или инструменты могли подключиться к базе

    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}" ]
      # Настраиваем проверку готовности контейнера — pg_isready проверяет, принимает ли база подключения
      # Добавляем параметр -d для указания конкретной базы данных
      interval: 10s  # Интервал между проверками — каждые 10 секунд
      timeout: 5s    # Время ожидания ответа от проверки
      retries: 5     # После 5 неудачных попыток подряд контейнер считается "unhealthy"

    restart: unless-stopped
    # Автоматически перезапускаем контейнер, если он аварийно завершился
    # Если контейнер был остановлен вручную — не перезапускаем

    networks:
      - microservices-net
      # Подключаемся к общей сети, чтобы другие микросервисы (например, Order-сервис) могли найти этот контейнер по имени "postgres-order"

volumes: # Раздел с томами — определяем, какие дисковые ресурсы создаёт и использует Docker
  postgres_order_data:
  # Именованный том для хранения данных Order-сервиса в PostgreSQL
  # Позволяет сохранять состояние базы даже после перезапуска контейнера

networks: # Сетевые настройки
  microservices-net:
    external: true
    # Мы не создаём новую сеть, а подключаемся к уже существующей общей сети "microservices-net"
    # Эта сеть создаётся один раз в docker-compose.yml или вручную через docker network create
